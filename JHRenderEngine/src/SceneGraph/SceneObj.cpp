//
//  SceneObj.cpp
//
//  Created by Jingshu Huang on 3/1/13.
//  Copyright (c) HuangImage 2013. All rights reserved.
//

#include <sstream>

#include "Behavior.h"
#include "Renderer.h"
#include "SceneMananger.h"
#include "SceneNode.h"
#include "SceneObj.h"


SceneObjID SceneObj::nextObjNamePrefix = 0;


string SceneObj::stringfyObjID(const SceneObjID& nId) {
    ostringstream stream;
    stream << nId;
    return stream.str();
}

SceneObj::SceneObj() {
    assert(false && "SceneObj::SceneObj default constructor is called.");
}

SceneObj::SceneObj(const string& name, const ESceneObjType& type) {
    reset();
    mObjID = nextObjNamePrefix++;
    mName = name;
    mObjType = type;
}

SceneObj::SceneObj(const string& name, const ESceneObjType& type,
                   SceneManager* sceneMgr, const ERenderQueueID& queueID) {
    reset();
    mObjID = nextObjNamePrefix++;
    mName = name;
    mObjType = type;

    mRenderQueueID = queueID;
    mSceneMgr = sceneMgr;
    mSceneNode = NULL;
}

SceneObj::~SceneObj() {
    reset();
}

void SceneObj::reset() {
    mName.clear();
    mRenderQueueID = QUEUE_5_MAIN;
    mSceneMgr = NULL;
    mSceneNode = NULL;
    mObjBound.reset();
    mWorldBound.reset();
}

void SceneObj::deepCopyFrom(SceneObj* other) {
    // mName should have been generated by now.
    mObjType = other->mObjType;

    mRenderQueueID = other->mRenderQueueID;
    mSceneMgr = other->mSceneMgr;
    mSceneNode = other->mSceneNode;

    mObjBound = other->mObjBound;
    mWorldBound = other->mWorldBound;

    // TODO(jhuang): for now, we do not copy.
}

RenderQueue* SceneObj::getRenderQueue() const {
    assert(mSceneMgr != NULL);
    return mSceneMgr->getRenderer()->getRenderQueue(mRenderQueueID);
}


#pragma mark - transformation and behaviors in world space

const Vector3& SceneObj::getFullWorldPosition(void) {
    assert(mSceneNode != NULL);
    return mSceneNode->getDerivedTranslate();
}

const Vector3& SceneObj::getFullWorldScale(void) {
    assert(mSceneNode != NULL);
    return mSceneNode->getDerivedScale();
}

const Quaternion& SceneObj::getFullWorldRotation(void) {
    assert(mSceneNode != NULL);
    return mSceneNode->getDerivedRotate();
}

// Get the full transform in the world space.
const Matrix4& SceneObj::getFullWorldTransform() const {
    if(mSceneNode) {
        return mSceneNode->getFullWorldTransform();
    }
    return Matrix4::IDENTITY;
}

//void SceneObj::setDirection(const Vector3& vec) {
//    setForwardVector(vec);
//}
//
//void SceneObj::setForwardVector(const Vector3& vec) {
//    assert(mSceneNode != NULL);
//    if (vec == Vector3::ZERO) {
//        return;
//    }
//
//    // Forward vector points down -Z of local axes. So reverse direction of direction
//    // vector before determining local Z
//    Vector3 newZvec = -vec;
//    newZvec.normalise();
//    // Get axes from current quaternion.
//    Vector3 axes[3];
////    Quaternion rotation = mSceneNode->getRotation();
//    Quaternion rotation = getFullWorldRotation();
//    rotation.ToAxes(axes);  // axes[2] is the old z vec.
//    // Derive shortest arc to new direction
//    Quaternion rotQuat = axes[2].getRotationTo(newZvec, axes[1]);
//    mSceneNode->rotate(rotQuat);
//}
//
//void SceneObj::lookAt(const Vector3& target) {
//    setDirection(target - getFullWorldPosition());
//}

Vector3 SceneObj::getForwardVector() {
    return getFullWorldRotation() * -Vector3::UNIT_Z;
}

const Quaternion& SceneObj::getOrientation(void) {
    return getFullWorldRotation();
}

Vector3 SceneObj::getUpVector() {
    return getFullWorldRotation() * Vector3::UNIT_Y;
}

Vector3 SceneObj::getRightVector() {
    return getFullWorldRotation() * Vector3::UNIT_X;
}


#pragma mark - transformation and behaviors in local space

void SceneObj::translate(const Vector3& vec) {
    assert(mSceneNode != NULL);
    mSceneNode->translate(vec);
}

void SceneObj::translateLocal(const Vector3& vec) {
    translate(vec);
}

void SceneObj::rotate(const Vector3& axis, const Radian& angle) {
    Quaternion q(angle, axis);
    rotate(q);
}

void SceneObj::rotate(const Quaternion& quat) {
    assert(mSceneNode != NULL);
    // Normalise the quat to avoid cumulative problems with precision (since
    // computers have fixed precisions.
    Quaternion q = quat;
    q.normalise();
    mSceneNode->rotate(quat);
}

// Rotate around local Z axis
void SceneObj::roll(const Radian& angle) {
    rotate(-getForwardVector(), angle);
}

// Rotate around local Y axis
void SceneObj::yaw(const Radian& angle) {
    rotate(getUpVector(), angle);
}

// Rotate around local X axis
void SceneObj::pitch(const Radian& angle) {
    rotate(getRightVector(), angle);
}

Behavior* SceneObj::getBehavior(const BehaviorType& type) {
    return mSceneNode ? mSceneNode->getBehavior(type) : NULL;
}

SceneNode* SceneObj::getClosestReactiveParentNode(const BehaviorType& type) {
    SceneNode* curNode = mSceneNode;
    while (curNode) {
        if (curNode->getBehavior(type) != NULL) {  // React to the behavior.
            return curNode;
        }
        curNode = static_cast<SceneNode*>(curNode->getParent());
    }
    return NULL;
}

#pragma mark - bound related

// Get the bound in world space.
const Bound& SceneObj::getWorldBound(const bool needUpdate) const {
    if (needUpdate) {
        // First get a scene object's (e.g entity) local bound.
        mWorldBound = getObjectBound();
        // Then transform the bound from the object space to world space.
        mWorldBound.getAABB().transformAffine(getFullWorldTransform());
    }

    return mWorldBound;
    
}

//const Sphere& SceneObj::getWorldBoundingSphere(const bool needUpdate) const {
//    if (needUpdate) {
//        const Vector3& scl = mParentNode->_getDerivedScale();
//        Real factor = std::max(std::max(scl.x, scl.y), scl.z);
//        mWorldBoundingSphere.setRadius(getBoundingRadius() * factor);
//        mWorldBoundingSphere.setCenter(mParentNode->_getDerivedPosition());
//    }
//    return mWorldBoundingSphere;
//}


//NSString *islandKey = [Island islandKey:i.islandNumber];
//IslandData *islandData = [[GameContext instance].islands objectForKey:islandKey];
//int userStars = [gcontext(userInfo).userData userStars];
//if (islandData.comingSoon) {
//    MessageDialogView *messageDialog = [MessageDialogView viewWithSuccessMessage:appStrings(@"LAST_LEVEL_COMPLETED")];
//    [messageDialog show];
//} else if (i.unlocked) {
//    if (![[DownloadManager instance] hasPackage:islandKey] && !islandData.bundled) {
//        [[MessageDialogView viewWithFailureMessage:appStrings(@"SELECT_ISLAND:NOT_DOWNLOADED")] show];
//    } else {
//        [self selectIslandAndMoveToPosition:i];
//        return;
//    }
//} else if ([i showLockThresholdBillboard]) {
//    NSString *replacedString = [appStrings(@"ERROR:LOCKED_STAR_THRESHOLD") stringByReplacingOccurrencesOfString:@"[number]" withString:@"%d"];
//    [[MessageDialogView viewWithFailureMessage:[NSString stringWithFormat:replacedString,
//                                                i.islandData.starThreshold - userStars]] show];
//} else if ([i showLockBillboard]) {
//    [[MessageDialogView viewWithFailureMessage:appStrings(@"ERROR:LOCKED_PARENT_ISLAND")] show];
//}
